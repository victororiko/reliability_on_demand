<#@ template language="c#" debug="true" hostspecific="true" #>
<#@ import namespace = "VcClient" #>
<#@ import namespace = "System.Collections.Generic" #>
<#@ import namespace = "System.IO" #>
<#@include file="ReadTextFromStream.scopet4" #>
<#@ import namespace = "System" #>
<#@ assembly name= "NEWTONSOFT.JSON.DLL" #>
<#@ import namespace = "Newtonsoft.Json" #>
<#@ import namespace = "Newtonsoft.Json.Linq" #>
<#@include file="ConfigurationHelper.scopet4" #>
<#@include file="DebugOutput.scopet4" #>
<#@include file="SchemaExplorer.scopet4" #>
<#@include file="GetLatestStreamDate.scopet4" #>
<#@include file="SaveTextToStream.scopet4" #>

/*
 --------------------------------------------------------------------------------------------------------------------
 <copyright file="RIOD.CensusDevices.script.scopet4" company="Microsoft Corporation">
     Copyright (c) Microsoft Corporation.  All rights reserved.
 </copyright>
 <summary>
Get the population from Device Census
 </summary>
<history>  
  03/12/2021 (dishah): Script has been created
</history>
 --------------------------------------------------------------------------------------------------------------------
*/

<#
    var context = Host.GetHostOption("T4Context") as IT4TransformContext;

    string inputFilterExpression = "!IsTestLab AND ((DeviceFamily ?? string.Empty).ToLowerInvariant()== \"windows.desktop\"";
    string outputFolder = @"/shares/asimov.prod.data/PublicPartner/Staging/Reliability/RIOD/Population";
    string outputStreamName = @"RIOD.Population.ss";
    int inputDayLookBack = 14;
    int inputMinBuildCutoff = 18362;
    string inputMADStream = "";
	string inputOSBuildDefinitionFile = @"/shares/asimov.prod.data/PublicPartner/Processed/Reliability/Resources/UnifiedSchema/UnifiedSchema.OS.Releases.json";
	int minBuild = int.MaxValue;
	int maxBuild = int.MinValue;
	string OSCadenceArray =  "";
	string applyUnifiedOSConfig = @"";
	List<int> retailBuilds = new List<int>();
    string inputCensusAttributes = "DeviceFamily,ProcessorModel,TotalPhysicalRAM,PrimaryDiskType,PrimaryDiskTypeName,ProcessorCores,ProcessorPhysicalCores,CommercialId,FlightRing,FirmwareVersion,OSArchitecture,StudyId,InternalSalesSegmentKey,VBSState,GenuineStateName,IsRetail,ISOCountryShortName,InstallationType,SMode,SModeState,WPId";

    // Check if we are running under XFlow
    if (context != null)
    {
        inputDayLookBack = (int)context.GetParameter<int>("_inputDayLookBack", inputDayLookBack);
        inputMinBuildCutoff = (int)context.GetParameter<int>("_inputMinBuildCutoff", inputMinBuildCutoff);
        inputFilterExpression = (string)context.GetParameter<string>("_inputFilterExpression", inputFilterExpression);
        outputFolder = (string)context.GetParameter<string>("_outputFolder", outputFolder);
        outputStreamName = (string)context.GetParameter<string>("_outputStreamName", outputStreamName);
        inputMADStream = (string)context.GetParameter<string>("_inputMADStream", inputMADStream);
		inputOSBuildDefinitionFile = (string)context.GetParameter<string>("_inputOSBuildDefinitionFile", inputOSBuildDefinitionFile);
		OSCadenceArray = (string)context.GetParameter<string>("_OSCadence", OSCadenceArray);
		applyUnifiedOSConfig = (string)context.GetParameter<string>("_applyUnifiedOSConfig", applyUnifiedOSConfig);
    }

	List<Dictionary<string, string>> streamsDefinition = new List<Dictionary<string, string>>();

    if (!string.IsNullOrEmpty(applyUnifiedOSConfig))
    {
        string streamsDefinitionContent = ReadTextFromStream(inputOSBuildDefinitionFile);
        streamsDefinition = ParseConfiguration(streamsDefinitionContent);
    }


	for (int i=0; i<streamsDefinition.Count; i++)
    {
		if ((OSCadenceArray.Contains(streamsDefinition[i]["OSCadence"])) && OSCadenceArray.Contains("Development"))
		{
			minBuild = Math.Min(minBuild,int.Parse(streamsDefinition[i]["MinBuild"]));
			maxBuild = Math.Max(maxBuild,int.Parse(streamsDefinition[i]["MaxBuild"]));
		}
		else if((OSCadenceArray.Equals(streamsDefinition[i]["OSCadence"])) && OSCadenceArray.Contains("Retail"))
		{
			retailBuilds.Add(int.Parse(streamsDefinition[i]["MinBuild"]));
		}
	}

#>

// Import Next Generation Privacy annotation module 
// Ref: https://microsoft.sharepoint.com/teams/ngphome/ngpx/execution/Official%20Documents/NGPX%20Technical%20Specifications/Privacy%20Tags%20Taxonomy.docx?web=1 
MODULE @"/shares/PXSCosmos15.Prod/PXS.DeleteSignal.PROD/PrivacyAnnotation/PrivacyAnnotation.module"; 
USING Privacy; 

#DECLARE inputMinBuildCutoff int = <#=inputMinBuildCutoff#>;
#DECLARE today DateTime = DateTime.UtcNow;
#DECLARE minLastSeenDateTime DateTime = @today.AddDays(-<#=inputDayLookBack#>);
#DECLARE expirationStreamCount string = "60";

// Census resources
#DECLARE rootFolder string = "/shares/asimov.prod.data";
#DECLARE deviceCensusDll string = String.Format("{0}/Public/Resources/Latest/Device/Microsoft.Telemetry.Device.Census.dll", @rootFolder);
#DECLARE commonUtilitiesDll string = String.Format("{0}/Public/Resources/Latest/Device/Microsoft.Telemetry.Common.Utilities.dll", @rootFolder);
#DECLARE commonParsersDll string = String.Format("{0}/Public/Resources/Latest/Device/Microsoft.Telemetry.Common.Parsers.dll", @rootFolder);

// Views
#DECLARE deviceCensusHistoricalView string = @"/shares/asimov.prod.data/Public/Processed/Device/Census/ConsolidatedHistory/DeviceCensusConsolidatedHistory.View";
#DECLARE deviceCensusView string = @"/shares/asimov.prod.data/Public/Processed/Device/Census/Consolidated/DeviceCensusConsolidated.View";
#DECLARE deviceModelHierarchyView string = @"/shares/asimov.prod.data/Public/Processed/Common/Dimensions/DimDeviceModelHierarchy.view";

#DECLARE outputStream string = @"<#=string.Format("{0}/{1}",outputFolder ,outputStreamName ) #>";

REFERENCE @deviceCensusDll;
REFERENCE @commonUtilitiesDll;
REFERENCE @commonParsersDll;

USING Microsoft.Telemetry.Device.Census;
USING Microsoft.Telemetry.Common.Utilities;
USING Microsoft.Telemetry.Common.Parsers;

// -----------------------------------------------------------------------------------------------------------------
// take data from history stream (combination of device id and OSVersion)

devicesAllOS = 
    SELECT OSVersionFull,
                   OSVersion,
                   !string.IsNullOrWhiteSpace(BuildNumber) ? (int?)int.Parse(BuildNumber) : (int?)null AS BuildNumber,
                   !string.IsNullOrWhiteSpace(BuildRevision) ? (int?)int.Parse(BuildRevision) : (int?)null AS BuildRevision,
                   (BuildBranch ?? string.Empty).ToLowerInvariant() AS BuildBranch,
                   DeviceId,
                   (LocalDeviceId ?? string.Empty) AS SqmId,
                   DeviceFamily AS _DeviceFamily,
                   IsTestLab,
                   IsMSFTOwned,
                   DeviceModel AS OldOEMModel,
                   OEMName_Uncleaned AS OldOEMName,
                   OEMModel AS MappingOEMModel,
                   ExpId AS ExpIds,
                   OSEdition AS SkuEdition,
                   LastUpdatedDate AS LastSeenEventDate,
                   DeviceModelId,
                   OSOOBEDateTime,
                   OSInstallTypeId,
                   OSInstallTypeName
    FROM ( VIEW @deviceCensusHistoricalView ) AS v
    WHERE BuildNumber != null && int.Parse(BuildNumber) > @inputMinBuildCutoff AND LastUpdatedDate  >= @minLastSeenDateTime;

// add missing attributes
devicesMostRecent =
    SELECT *
    FROM (VIEW @deviceCensusView)
 WHERE OSBuildNumber > @inputMinBuildCutoff AND LastUpdatedDate  >= @minLastSeenDateTime;

deviceDimModelView = 
     SELECT *
     FROM (VIEW @deviceModelHierarchyView);

devices = 
    SELECT daos.*,
                   h.OEMManufacturer AS OEMName,
                   h.OEMProductName AS OEMModel,
<#
    foreach(string columnName in inputCensusAttributes.Split(','))
    {
#>
    dmr.<#=columnName#> AS <#=columnName#>,
<#
    }
#>        <#=string.IsNullOrEmpty(inputMADStream) ? "(bool)false" : "mad.DeviceId != null" #> AS IsMAD,
            ROW_NUMBER() OVER(PARTITION BY DeviceId, daos.BuildNumber, daos.BuildRevision ORDER BY LastUpdatedDate DESC) AS DevicePrevalence
    FROM devicesAllOS AS daos
    INNER JOIN devicesMostRecent AS dmr ON daos.DeviceId == dmr.DeviceId
    LEFT OUTER JOIN deviceDimModelView AS h ON dmr.ModelHierarchyId == h.ModelHierarchyId
<# if (!string.IsNullOrEmpty(inputMADStream)) { #>
    LEFT OUTER JOIN (SSTREAM @"<#=inputMADStream#>") AS mad ON dmr.DeviceId == mad.DeviceId
 <# } #>;

devices = SELECT DISTINCT d.*
          FROM devices AS d;

//  output intermediate machines
[Privacy.DataType.ProductAndServicePerformance]
[Privacy.Subject.Device.CommonSchema(Column="DeviceId")]
[Privacy.DataType.DeviceConnectivityAndConfiguration] 
[Privacy.DataType.DeviceConnectivityAndConfiguration.Related(Column="OSVersion")]
[Privacy.DataType.DeviceConnectivityAndConfiguration.Related(Column="OEMModel")]
[Privacy.DataType.DeviceConnectivityAndConfiguration.Related(Column="OEMName")]
OUTPUT devices
TO SSTREAM @outputStream
CLUSTERED BY DeviceId, OSVersion
SORTED BY DeviceId, OSVersion
WITH STREAMEXPIRY @expirationStreamCount
WHERE DevicePrevalence == 1 AND (<#= inputFilterExpression#>) <#= string.IsNullOrEmpty(applyUnifiedOSConfig)? "" : ( OSCadenceArray.Contains("Development") ? (" AND BuildNumber >=" + minBuild + " AND BuildNumber <="+ maxBuild) : ( " AND BuildNumber IN (" + (string.Join(",", retailBuilds.ToArray())) + ")")) #>;